# Copyright (c) 2025 Efstratios Goudelis
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# This file contains code partially generated by Claude 3.7 Sonnet.

import json
import logging
from typing import Dict, Union

import numpy as np
from skyfield.api import EarthSatellite, Loader, Topos

from common.common import ModelEncoder

logger = logging.getLogger("passes-worker")


def calculate_next_events(
    satellite_data: Union[Dict, list],
    home_location: Dict[str, float],
    hours: float = 6.0,
    above_el=0,
    step_minutes=1,
) -> Dict:
    """
    This function calculates upcoming satellite observation events based on satellite data, observation location,
    duration, and elevation threshold. It primarily uses Skyfield's efficient find_events method.
    If find_events yields no results for a satellite, it falls back to a more exhaustive time-step
    approach to ensure all passes are detected.

    :param satellite_data: Either a single satellite dictionary or list of satellite dictionaries,
        each containing 'norad_id', 'tle1', 'tle2', and other satellite information
    :param home_location: Dictionary containing 'lat' and 'lon' keys with float values for observer location
    :param hours: Observation duration in hours.
    :param above_el: Minimum elevation angle (in degrees) above the horizon for
        an event to be considered. Default is 0.
    :param step_minutes: Time step in minutes for evaluating satellite positions,
        used only in the fallback time-step method. Default is 1 minute.
    :return: Dictionary containing the calculated satellite pass events,
        parameters used for computation, and a success flag.
    :rtype: dict
    """

    reply: Dict[str, Union[bool, None, list, None, Dict, str]] = {
        "success": None,
        "data": None,
        "parameters": None,
        "error": None,
    }
    events = []

    # Convert satellite_data to tle_groups format for processing
    tle_groups = []
    satellite_info = {}  # Map norad_id to full satellite data

    if isinstance(satellite_data, dict):
        # Single satellite case
        tle_groups = [[satellite_data["norad_id"], satellite_data["tle1"], satellite_data["tle2"]]]
        satellite_info[satellite_data["norad_id"]] = satellite_data
        satellites_count = 1
    elif isinstance(satellite_data, list) and len(satellite_data) > 0:
        # Multiple satellites case
        if isinstance(satellite_data[0], dict):
            # List of satellite dictionaries
            for sat in satellite_data:
                tle_groups.append([sat["norad_id"], sat["tle1"], sat["tle2"]])
                satellite_info[sat["norad_id"]] = sat
            satellites_count = len(satellite_data)
        else:
            # Fallback for old format (list of tle_groups directly)
            tle_groups = satellite_data
            satellites_count = len(satellite_data)
    else:
        # Invalid input
        reply["success"] = False
        reply["error"] = "Invalid satellite_data format. Expected dict or list of dicts."
        return reply

    logger.info(f"Calculating passes for {satellites_count} satellites for the next {hours} hours.")

    try:
        assert isinstance(tle_groups, list), "tle_groups must be a list of lists"
        assert all(
            len(group) == 3 for group in tle_groups
        ), "Each TLE group must contain norad_id and 2 TLE lines"
        assert isinstance(home_location, dict), "home_location must be a dictionary"
        assert (
            "lat" in home_location and "lon" in home_location
        ), "home_location must contain 'lat' and 'lon' keys"

        # set a temporary folder for the skyfield library to do its thing
        skyfieldloader = Loader("/tmp/skyfield-data")  # or any preferred path
        ts = skyfieldloader.timescale()

        homelat = float(home_location["lat"])
        homelon = float(home_location["lon"])

        # Coordinates can be in decimal degrees:
        observer = Topos(latitude_degrees=homelat, longitude_degrees=homelon)

        # Build a time range for pass calculation
        t0 = ts.now()
        t_end = t0 + (hours / 24.0)

        for tle_group in tle_groups:
            norad_id, line1, line2 = tle_group

            # Check for extreme orbital decay indicators in TLE
            # The First Derivative of Mean Motion (columns 34-43) indicates orbital decay rate
            # High values (>0.01) indicate rapid orbital decay and will cause propagation issues
            try:
                # Extract first derivative of mean motion (columns 34-43, 0-indexed: 33-42)
                # Format: ±.dddddddd (decimal value with explicit decimal point)
                # Example: " .11903621" = 0.11903621
                # Example: " .00013419" = 0.00013419 (normal)
                ndot_str = line1[33:43].strip()
                if ndot_str:
                    ndot = float(ndot_str)
                    ndot_threshold = 0.01

                    if abs(ndot) > ndot_threshold:
                        logger.error(
                            f"Satellite {norad_id} skipped: Extreme first derivative of mean motion {ndot:.8f} "
                            f"(threshold: {ndot_threshold}). This satellite is in rapid orbital decay and "
                            f"will cause performance issues during propagation."
                        )
                        continue  # Skip this satellite
            except (ValueError, IndexError) as e:
                logger.warning(f"Failed to parse first derivative for satellite {norad_id}: {e}")
                # Continue anyway - if we can't parse, let Skyfield try

            satellite = EarthSatellite(line1, line2, name=f"satellite_{norad_id}")

            # Check if it is geostationary or geosynchronous
            satellite_orbit_info = analyze_satellite_orbit(satellite)
            is_geostationary = satellite_orbit_info["is_geostationary"]
            is_geosynchronous = satellite_orbit_info["is_geosynchronous"]

            # Get the status from the satellite info
            status = satellite_info.get(norad_id, {}).get("status", None)

            difference = satellite - observer
            satellite_events = []

            # APPROACH 1: Use find_events method as the primary, efficient approach
            times, events_type = satellite.find_events(
                observer, t0, t_end, altitude_degrees=above_el
            )

            logger.debug(
                f"find_events method found {len(times)} times and events {events_type} for satellite {norad_id}"
            )

            # First, check if the satellite is already visible at the start time
            topocentric = difference.at(t0)
            alt, az, distance = topocentric.altaz()
            already_visible = alt.degrees > above_el

            # Process the events into passes
            current_pass = {}

            # If already visible at start time and first event is not a rise event
            if already_visible and (len(times) == 0 or events_type[0] != 0):
                # Find the actual rise time by looking backward
                actual_rise_time = backtrack_rise_time(satellite, observer, t0, above_el)
                current_pass = {"start_time": actual_rise_time, "norad_id": norad_id}

            # Process all the find_events results
            for i, (time, event_type) in enumerate(zip(times, events_type)):
                if event_type == 0:  # Rise event
                    # Start a new pass
                    current_pass = {"start_time": time, "norad_id": norad_id}
                elif event_type == 1 and "start_time" in current_pass:  # Culmination event
                    # This is the peak of the current pass
                    current_pass["peak_time"] = time

                elif event_type == 2 and "start_time" in current_pass:  # Set event
                    # This completes the current pass
                    current_pass["end_time"] = time

                    # Calculate additional information for this pass
                    topocentric = difference.at(current_pass["start_time"])
                    alt_start, az_start, dist_start = topocentric.altaz()
                    start_az_value = float(az_start.degrees)

                    if "peak_time" in current_pass:
                        topocentric = difference.at(current_pass["peak_time"])
                        alt_peak, az_peak, dist_peak = topocentric.altaz()
                        alt_peak_value = float(alt_peak.degrees)
                        az_peak_value = float(az_peak.degrees)
                        dist_peak_value = float(dist_peak.km)
                    else:
                        # If we don't have a culmination event, find the peak
                        # Check several points between start and end
                        num_checks = 20
                        check_times = current_pass["start_time"] + np.linspace(
                            0,
                            (current_pass["end_time"].tt - current_pass["start_time"].tt),
                            num_checks,
                        )

                        max_alt = float(alt_start.degrees)
                        peak_time = current_pass["start_time"]
                        peak_az = float(az_start.degrees)
                        peak_dist = float(dist_start.km)

                        for check_time in check_times:
                            topocentric = difference.at(check_time)
                            check_alt, check_az, check_dist = topocentric.altaz()
                            if check_alt.degrees > max_alt:
                                max_alt = float(check_alt.degrees)
                                peak_time = check_time
                                peak_az = float(check_az.degrees)
                                peak_dist = float(check_dist.km)

                        current_pass["peak_time"] = peak_time
                        alt_peak_value = max_alt
                        az_peak_value = peak_az
                        dist_peak_value = peak_dist

                    topocentric = difference.at(current_pass["end_time"])
                    alt_end, az_end, dist_end = topocentric.altaz()
                    end_az_value = float(az_end.degrees)

                    duration = (
                        current_pass["end_time"].utc_datetime()
                        - current_pass["start_time"].utc_datetime()
                    )

                    satellite_events.append(
                        {
                            "norad_id": norad_id,
                            "status": status,
                            "is_geostationary": is_geostationary,
                            "is_geosynchronous": is_geosynchronous,
                            "event_start": current_pass["start_time"].utc_iso(),
                            "event_end": current_pass["end_time"].utc_iso(),
                            "duration": duration,
                            "distance_at_start": float(dist_start.km),
                            "distance_at_end": float(dist_end.km),
                            "distance_at_peak": float(dist_peak_value),
                            "peak_altitude": float(alt_peak_value),
                            "start_azimuth": start_az_value,
                            "end_azimuth": end_az_value,
                            "peak_azimuth": float(az_peak_value),
                        }
                    )

                    current_pass = {}

            # Handle incomplete passes (satellite visible at the end of time window)
            if current_pass and "start_time" in current_pass:
                # We have a pass that started but didn't finish in our time window

                # Find the culmination point if we don't have one
                if "peak_time" not in current_pass:
                    # Sample points to find maximum altitude
                    num_checks = 20
                    check_times = current_pass["start_time"] + np.linspace(
                        0, (t_end.tt - current_pass["start_time"].tt), num_checks
                    )

                    topocentric = difference.at(current_pass["start_time"])
                    alt_start, az_start, dist_start = topocentric.altaz()
                    start_az_value = float(az_start.degrees)

                    max_alt = float(alt_start.degrees)
                    peak_time = current_pass["start_time"]
                    peak_az = float(az_start.degrees)
                    peak_dist = float(dist_start.km)

                    for check_time in check_times:
                        topocentric = difference.at(check_time)
                        check_alt, check_az, check_dist = topocentric.altaz()
                        if check_alt.degrees > max_alt:
                            max_alt = float(check_alt.degrees)
                            peak_time = check_time
                            peak_az = float(check_az.degrees)
                            peak_dist = float(check_dist.km)

                    current_pass["peak_time"] = peak_time
                    alt_peak_value = max_alt
                    az_peak_value = peak_az
                    dist_peak_value = peak_dist
                else:
                    topocentric = difference.at(current_pass["peak_time"])
                    alt_peak, az_peak, dist_peak = topocentric.altaz()
                    alt_peak_value = float(alt_peak.degrees)
                    az_peak_value = float(az_peak.degrees)
                    dist_peak_value = float(dist_peak.km)

                # Use t_end as the end time for now
                current_pass["end_time"] = t_end

                # Calculate metrics
                topocentric = difference.at(current_pass["start_time"])
                alt_start, az_start, dist_start = topocentric.altaz()
                start_az_value = float(az_start.degrees)

                topocentric = difference.at(current_pass["end_time"])
                alt_end, az_end, dist_end = topocentric.altaz()
                end_az_value = float(az_end.degrees)

                duration = (
                    current_pass["end_time"].utc_datetime()
                    - current_pass["start_time"].utc_datetime()
                )

                satellite_events.append(
                    {
                        "norad_id": norad_id,
                        "status": status,
                        "is_geostationary": is_geostationary,
                        "is_geosynchronous": is_geosynchronous,
                        "event_start": current_pass["start_time"].utc_iso(),
                        "event_end": current_pass["end_time"].utc_iso(),
                        "duration": duration,
                        "distance_at_start": float(dist_start.km),
                        "distance_at_end": float(dist_end.km),
                        "distance_at_peak": float(dist_peak_value),
                        "peak_altitude": float(alt_peak_value),
                        "start_azimuth": start_az_value,
                        "end_azimuth": end_az_value,
                        "peak_azimuth": float(az_peak_value),
                        "estimated_end": True,
                    }
                )

            if satellite_events:
                logger.debug(
                    f"find_events method found {len(satellite_events)} passes for satellite {norad_id}"
                )
                events.extend(satellite_events)
            else:
                logger.debug(
                    f"find_events found no passes for satellite {norad_id}. Falling back to time-step method."
                )

                # APPROACH 2: Fallback to traditional time-step method
                t_points = t0 + (np.arange(0, int(hours * 60), step_minutes) / (24.0 * 60.0))
                altitudes = []
                azimuths = []
                distances = []

                for t in t_points:
                    topocentric = difference.at(t)
                    alt, az, distance = topocentric.altaz()
                    altitudes.append(float(alt.degrees))
                    azimuths.append(float(az.degrees))
                    distances.append(float(distance.km))

                # Find "passes" by looking for intervals where alt > above_el
                above_threshold = np.array(altitudes) > above_el

                # For a simple pass report, find start/end indices of each pass
                passes = []
                in_pass = False
                pass_start_index: int = 0

                for i in range(len(above_threshold)):
                    if above_threshold[i] and not in_pass:
                        # We are just now rising above the threshold
                        in_pass = True
                        pass_start_index = i

                    elif not above_threshold[i] and in_pass:
                        # We just fell below the threshold
                        in_pass = False
                        pass_end_index = i - 1  # Last index when above the threshold
                        passes.append((pass_start_index, pass_end_index))

                # If the last pass goes until the end of the array, close it out
                if in_pass:
                    passes.append((pass_start_index, len(above_threshold) - 1))

                # Process the passes found by the time-step method
                timestep_events = []
                for start_i, end_i in passes:
                    start_time = t_points[start_i]
                    end_time = t_points[end_i]

                    # Extract the slice of data for this pass
                    pass_altitudes = altitudes[start_i : end_i + 1]
                    pass_azimuths = azimuths[start_i : end_i + 1]
                    pass_distances = distances[start_i : end_i + 1]

                    # Find the index of maximum elevation within this pass
                    peak_i = int(np.argmax(pass_altitudes))
                    peak_time = t_points[start_i + peak_i]

                    duration = end_time.utc_datetime() - start_time.utc_datetime()

                    timestep_events.append(
                        {
                            "norad_id": norad_id,
                            "status": status,
                            "is_geostationary": is_geostationary,
                            "is_geosynchronous": is_geosynchronous,
                            "event_start": start_time.utc_iso(),
                            "event_end": end_time.utc_iso(),
                            "duration": duration,
                            "distance_at_start": float(distances[start_i]),
                            "distance_at_end": float(distances[end_i]),
                            "distance_at_peak": float(pass_distances[peak_i]),
                            "peak_altitude": float(pass_altitudes[peak_i]),
                            "start_azimuth": float(azimuths[start_i]),
                            "end_azimuth": float(azimuths[end_i]),
                            "peak_azimuth": float(pass_azimuths[peak_i]),
                        }
                    )

                if timestep_events:
                    logger.debug(
                        f"Time-step method found {len(timestep_events)} passes for satellite {norad_id}"
                    )
                    events.extend(timestep_events)
                else:
                    logger.debug(f"No passes found for satellite {norad_id} using either method.")

        # Apply final sorting and ID renumbering
        events.sort(key=lambda e: e["event_start"])
        for i, event in enumerate(events, 1):
            event["id"] = i

        # Convert to JSON
        events = json.loads(json.dumps(events, cls=ModelEncoder))

        reply["data"] = events
        reply["parameters"] = {
            "satellite_count": satellites_count,
            "hours": hours,
            "above_el": above_el,
            "step_minutes": step_minutes,
        }
        reply["success"] = True

    except Exception as e:
        logger.error(f"Failed to calculate satellite events, error: {e}")
        logger.exception(e)
        reply["success"] = False
        reply["error"] = str(e)

    return reply


def analyze_satellite_orbit(satellite):
    """
    Analyze a satellite's orbit to determine if it's geosynchronous or geostationary.

    :param satellite: A Skyfield EarthSatellite object
    :return: Dictionary with orbit analysis results
    """
    try:
        # In Skyfield, the orbital elements are accessed differently
        # Semi-major axis is in earth radii, convert to km
        semi_major_axis = satellite.model.a * 6378.137  # Earth radius in km
        eccentricity = satellite.model.ecco
        inclination = np.degrees(satellite.model.inclo)  # Convert radians to degrees

        # Calculate orbital period (in minutes)
        # Using Kepler's Third Law: T² ∝ a³
        period_minutes = 2 * np.pi * np.sqrt(semi_major_axis**3 / 398600.4418) / 60

        # Check if period matches sidereal day (~23h 56m or 1436 minutes)
        # Use 30 minutes tolerance to account for orbital variations
        period_ok = abs(period_minutes - 1436) < 30

        # Determine orbit type
        is_geosynchronous = period_ok
        is_geostationary = is_geosynchronous and (abs(inclination) < 5) and (eccentricity < 0.1)

        return {
            "is_geosynchronous": is_geosynchronous,
            "is_geostationary": is_geostationary,
            "orbital_period_minutes": round(period_minutes, 2),
            "inclination": round(inclination, 2),
            "eccentricity": round(eccentricity, 4),
        }
    except (AttributeError, ValueError, TypeError) as e:
        logger.warning(f"Error analyzing satellite orbit: {e}")
        return {"is_geosynchronous": False, "is_geostationary": False, "error": str(e)}


def calculate_azimuth_path(azimuths):
    """
    Calculate the display parameters for a satellite path on a clockwise-only radar widget.

    This function determines the correct start and end points to draw a clockwise arc
    that accurately represents the satellite's path, regardless of the actual direction
    of movement.

    Args:
        azimuths: List of azimuth values in degrees representing a satellite pass

    Returns:
        Tuple of (display_start, display_end, arc_angle)
        - display_start: The starting azimuth for drawing the clockwise arc (0-360)
        - display_end: The ending azimuth for drawing the clockwise arc (0-360)
        - arc_angle: The angle to draw in clockwise direction (0-360)
    """
    if not azimuths or len(azimuths) < 2:
        return 0, 0, 0

    # Normalize all azimuths to 0-360 range
    normalized = [az % 360 for az in azimuths]

    # Get the actual start and end azimuths
    actual_start = normalized[0]
    actual_end = normalized[-1]

    # Determine if the satellite is actually moving clockwise or counterclockwise
    is_clockwise = False
    total_movement = 0

    for i in range(len(normalized) - 1):
        current = normalized[i]
        next_az = normalized[i + 1]

        # Calculate difference, handling north crossing
        diff = next_az - current

        # Adjust for crossing north
        if diff > 180:
            diff -= 360
        elif diff < -180:
            diff += 360

        total_movement += diff

    # If total movement is negative, the satellite is moving clockwise
    is_clockwise = total_movement < 0

    # For a clockwise-only display, we need to adjust based on actual movement:
    if is_clockwise:
        # Already clockwise, display as is
        display_start = actual_start
        display_end = actual_end

        # Calculate the clockwise angle
        if display_end > display_start:
            arc_angle = 360 - (display_end - display_start)
        else:
            arc_angle = display_start - display_end
    else:
        # Counterclockwise movement; reverse start and end for clockwise display
        display_start = actual_end
        display_end = actual_start

        # Calculate the clockwise angle
        if display_end > display_start:
            arc_angle = 360 - (display_end - display_start)
        else:
            arc_angle = display_start - display_end

    return display_start, display_end, arc_angle


def backtrack_rise_time(satellite, observer, t0, above_el, backtrack_hours=6.0):
    """
    Work backward in time to find when a satellite actually rose above the horizon
    when it's already visible at start time.
    """
    # Create a timescale that goes backward from t0
    t_start = t0 - (backtrack_hours / 24.0)

    # Use find_events to find any rise events in the past
    times, events_type = satellite.find_events(observer, t_start, t0, altitude_degrees=above_el)

    # If we found any rise events, the last one is the start of the current pass
    rise_events = [
        (time, event_type) for time, event_type in zip(times, events_type) if event_type == 0
    ]
    if rise_events:
        # Return the most recent rise event
        return rise_events[-1][0]

    # If no rise events found, use coarse timestep method to approximate
    difference = satellite - observer
    step_minutes = 5  # Use a coarser timestep for efficiency
    t_points = t_start + (np.arange(0, int(backtrack_hours * 60), step_minutes) / (24.0 * 60.0))

    # Calculate altitudes going backward
    altitudes = []
    for t in t_points:
        topocentric = difference.at(t)
        alt, _, _ = topocentric.altaz()
        altitudes.append(float(alt.degrees))

    # Find transitions from below to above elevation threshold
    above_threshold = np.array(altitudes) > above_el

    # Walk through backward and find first point where satellite is below threshold
    for i in range(len(above_threshold)):
        if not above_threshold[i]:
            # Return the time just after this point (when it first appeared)
            if i < len(t_points) - 1:
                # Interpolate to find a more precise time
                return t_points[i + 1]
            break

    # If we get here, we couldn't find a rise time, so return t0
    return t0
