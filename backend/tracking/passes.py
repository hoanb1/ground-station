# Copyright (c) 2025 Efstratios Goudelis
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# This file contains code partially generated by Claude 3.7 Sonnet.


import json
import logging
import numpy as np
from skyfield.api import Loader, Topos
from common.common import ModelEncoder
from skyfield.api import EarthSatellite
from typing import Union

logger = logging.getLogger('passes-worker')



def calculate_next_events(tle_groups: list[list[str]], home_location: dict[str, float], hours: float = 6.0,
                          above_el=0, step_minutes=1) -> dict:
    """
    This function calculates upcoming satellite observation events based on TLE lines, observation location,
    duration, elevation threshold, and time step. It combines Skyfield's find_events method with
    a more thorough time-step approach to ensure all passes are detected.

    :param tle_groups: List of lists containing three strings each: [norad_id, TLE line 1, TLE line 2]
    :param home_location: Dictionary containing 'lat' and 'lon' keys with float values for observer location
    :param hours: Observation duration in hours.
    :param above_el: Minimum elevation angle (in degrees) above the horizon for
        an event to be considered. Default is 0.
    :param step_minutes: Time step in minutes for evaluating satellite positions.
        Smaller time steps increase calculation accuracy. Default is 0.5 minutes.
    :return: Dictionary containing the calculated satellite pass events,
        parameters used for computation, and a success flag.
    :rtype: dict
    """

    reply: dict[str, Union[bool, None, list, None, dict, str]] = {'success': None, 'data': None, 'parameters': None, 'error': None}
    events = []

    logger.info(f"Calculating passes for {len(tle_groups)} satellites for the next {hours} hours.")

    try:
        assert isinstance(tle_groups, list), "tle_groups must be a list of lists"
        assert all(len(group) == 3 for group in tle_groups), "Each TLE group must contain norad_id and 2 TLE lines"
        assert isinstance(home_location, dict), "home_location must be a dictionary"
        assert 'lat' in home_location and 'lon' in home_location, "home_location must contain 'lat' and 'lon' keys"

        # set a temporary folder for the skyfield library to do its thing
        skyfieldloader = Loader('/tmp/skyfield-data')  # or any preferred path
        ts = skyfieldloader.timescale()

        homelat = float(home_location['lat'])
        homelon = float(home_location['lon'])

        # Coordinates can be in decimal degrees:
        observer = Topos(latitude_degrees=homelat, longitude_degrees=homelon)

        # Build a time range for pass calculation
        t0 = ts.now()
        t_end = t0 + (hours / 24.0)

        # Step through times using the original step_minutes approach for thoroughness
        # This helps catch passes that might be missed by find_events()
        t_points = t0 + (np.arange(0, int(hours * 60), step_minutes) / (24.0 * 60.0))

        event_id = 1
        for tle_group in tle_groups:
            norad_id, line1, line2 = tle_group

            satellite = EarthSatellite(
                line1,
                line2,
                name=f"satellite_{norad_id}"
            )

            # Check if it is geostationary or geosynchronous
            satellite_orbit_info = analyze_satellite_orbit(satellite)
            is_geostationary = satellite_orbit_info['is_geostationary']
            is_geosynchronous = satellite_orbit_info['is_geosynchronous']

            # APPROACH 1: Use traditional time-step method to ensure we don't miss any passes
            difference = satellite - observer
            altitudes = []
            azimuths = []
            distances = []

            for t in t_points:
                topocentric = difference.at(t)
                alt, az, distance = topocentric.altaz()
                altitudes.append(float(alt.degrees))
                azimuths.append(float(az.degrees))
                distances.append(float(distance.km))

            # Find "passes" by looking for intervals where alt > above_el
            above_threshold = np.array(altitudes) > above_el

            # For a simple pass report, find start/end indices of each pass
            passes = []
            in_pass = False
            pass_start_index = None

            for i in range(len(above_threshold)):
                if above_threshold[i] and not in_pass:
                    # We are just now rising above the threshold
                    in_pass = True
                    pass_start_index = i

                elif not above_threshold[i] and in_pass:
                    # We just fell below the threshold
                    in_pass = False
                    pass_end_index = i - 1  # Last index when above the threshold
                    passes.append((pass_start_index, pass_end_index))

            # If the last pass goes until the end of the array, close it out
            if in_pass:
                passes.append((pass_start_index, len(above_threshold) - 1))

            # Process the passes found by the time-step method
            for start_i, end_i in passes:
                start_time = t_points[start_i]
                end_time = t_points[end_i]

                # Extract the slice of data for this pass
                pass_altitudes = altitudes[start_i:end_i + 1]
                pass_azimuths = azimuths[start_i:end_i + 1]
                pass_distances = distances[start_i:end_i + 1]

                # Find the index of maximum elevation within this pass
                peak_i = np.argmax(pass_altitudes)
                peak_time = t_points[start_i + peak_i]

                duration = end_time.utc_datetime() - start_time.utc_datetime()

                events.append({
                    'id': event_id,
                    'norad_id': norad_id,
                    'is_geostationary': is_geostationary,
                    'is_geosynchronous': is_geosynchronous,
                    'event_start': start_time.utc_iso(),
                    'event_end': end_time.utc_iso(),
                    'duration': duration,
                    'distance_at_start': float(distances[start_i]),
                    'distance_at_end': float(distances[end_i]),
                    'distance_at_peak': float(pass_distances[peak_i]),
                    'peak_altitude': float(pass_altitudes[peak_i]),
                    'start_azimuth': float(azimuths[start_i]),
                    'end_azimuth': float(azimuths[end_i]),
                    'peak_azimuth': float(pass_azimuths[peak_i]),
                    'method': 'time-step'
                })
                event_id += 1


            else:
                logger.debug(f"No passes found for satellite {norad_id}")

            logger.debug(f"Approach #1: Found {len(passes)} passes for satellite {norad_id}")

            # APPROACH 2: Also use find_events method for more precise timing
            # Find all rise/culminate/set events in the time window
            times, events_type = satellite.find_events(
                observer,
                t0,
                t_end,
                altitude_degrees=above_el
            )

            logger.debug(f"Approach #2: Found {times} times and events {events_type} for satellite {norad_id}")

            # First, check if the satellite is already visible at the start time
            topocentric = difference.at(t0)
            alt, az, distance = topocentric.altaz()
            already_visible = alt.degrees > above_el

            # Process the events into passes
            current_pass = {}

            # If already visible at start time and first event is not a rise event
            if already_visible and (len(times) == 0 or events_type[0] != 0):
                # Find the actual rise time by looking backward
                actual_rise_time = backtrack_rise_time(satellite, observer, t0, above_el)
                current_pass = {
                    'start_time': actual_rise_time,
                    'norad_id': norad_id
                }

            # Process all the find_events results
            for i, (time, event_type) in enumerate(zip(times, events_type)):
                if event_type == 0:  # Rise event
                    # Start a new pass
                    current_pass = {
                        'start_time': time,
                        'norad_id': norad_id
                    }
                elif event_type == 1 and 'start_time' in current_pass:  # Culmination event
                    # This is the peak of the current pass
                    current_pass['peak_time'] = time

                elif event_type == 2 and 'start_time' in current_pass:  # Set event
                    # This completes the current pass
                    current_pass['end_time'] = time

                    # Calculate additional information for this pass
                    topocentric = difference.at(current_pass['start_time'])
                    alt_start, az_start, dist_start = topocentric.altaz()
                    start_az_value = float(az_start.degrees)

                    if 'peak_time' in current_pass:
                        topocentric = difference.at(current_pass['peak_time'])
                        alt_peak, az_peak, dist_peak = topocentric.altaz()
                        alt_peak_value = float(alt_peak.degrees)
                        az_peak_value = float(az_peak.degrees)
                        dist_peak_value = float(dist_peak.km)
                    else:
                        # If we don't have a culmination event, find the peak
                        # Check several points between start and end
                        num_checks = 20
                        check_times = current_pass['start_time'] + np.linspace(
                            0,
                            (current_pass['end_time'].tt - current_pass['start_time'].tt),
                            num_checks
                        )

                        max_alt = float(alt_start.degrees)
                        peak_time = current_pass['start_time']
                        peak_az = float(az_start.degrees)
                        peak_dist = float(dist_start.km)

                        for check_time in check_times:
                            topocentric = difference.at(check_time)
                            check_alt, check_az, check_dist = topocentric.altaz()
                            if check_alt.degrees > max_alt:
                                max_alt = float(check_alt.degrees)
                                peak_time = check_time
                                peak_az = float(check_az.degrees)
                                peak_dist = float(check_dist.km)

                        current_pass['peak_time'] = peak_time
                        alt_peak_value = max_alt
                        az_peak_value = peak_az
                        dist_peak_value = peak_dist

                    topocentric = difference.at(current_pass['end_time'])
                    alt_end, az_end, dist_end = topocentric.altaz()
                    end_az_value = float(az_end.degrees)

                    duration = current_pass['end_time'].utc_datetime() - current_pass['start_time'].utc_datetime()

                    events.append({
                        'id': event_id,
                        'norad_id': norad_id,
                        'is_geostationary': is_geostationary,
                        'is_geosynchronous': is_geosynchronous,
                        'event_start': current_pass['start_time'].utc_iso(),
                        'event_end': current_pass['end_time'].utc_iso(),
                        'duration': duration,
                        'distance_at_start': float(dist_start.km),
                        'distance_at_end': float(dist_end.km),
                        'distance_at_peak': float(dist_peak_value),
                        'peak_altitude': float(alt_peak_value),
                        'start_azimuth': start_az_value,
                        'end_azimuth': end_az_value,
                        'peak_azimuth': float(az_peak_value),
                        'method': 'find_events'
                    })

                    event_id += 1
                    current_pass = {}

            # Handle incomplete passes (satellite visible at the end of time window)
            if current_pass and 'start_time' in current_pass:
                # We have a pass that started but didn't finish in our time window

                # Find the culmination point if we don't have one
                if 'peak_time' not in current_pass:
                    # Sample points to find maximum altitude
                    num_checks = 20
                    check_times = current_pass['start_time'] + np.linspace(
                        0,
                        (t_end.tt - current_pass['start_time'].tt),
                        num_checks
                    )

                    topocentric = difference.at(current_pass['start_time'])
                    alt_start, az_start, dist_start = topocentric.altaz()
                    start_az_value = float(az_start.degrees)

                    max_alt = float(alt_start.degrees)
                    peak_time = current_pass['start_time']
                    peak_az = float(az_start.degrees)
                    peak_dist = float(dist_start.km)

                    for check_time in check_times:
                        topocentric = difference.at(check_time)
                        check_alt, check_az, check_dist = topocentric.altaz()
                        if check_alt.degrees > max_alt:
                            max_alt = float(check_alt.degrees)
                            peak_time = check_time
                            peak_az = float(check_az.degrees)
                            peak_dist = float(check_dist.km)

                    current_pass['peak_time'] = peak_time
                    alt_peak_value = max_alt
                    az_peak_value = peak_az
                    dist_peak_value = peak_dist
                else:
                    topocentric = difference.at(current_pass['peak_time'])
                    alt_peak, az_peak, dist_peak = topocentric.altaz()
                    alt_peak_value = float(alt_peak.degrees)
                    az_peak_value = float(az_peak.degrees)
                    dist_peak_value = float(dist_peak.km)

                # Use t_end as the end time for now
                current_pass['end_time'] = t_end

                # Calculate metrics
                topocentric = difference.at(current_pass['start_time'])
                alt_start, az_start, dist_start = topocentric.altaz()
                start_az_value = float(az_start.degrees)

                topocentric = difference.at(current_pass['end_time'])
                alt_end, az_end, dist_end = topocentric.altaz()
                end_az_value = float(az_end.degrees)

                duration = current_pass['end_time'].utc_datetime() - current_pass['start_time'].utc_datetime()

                events.append({
                    'id': event_id,
                    'norad_id': norad_id,
                    'is_geostationary': is_geostationary,
                    'is_geosynchronous': is_geosynchronous,
                    'event_start': current_pass['start_time'].utc_iso(),
                    'event_end': current_pass['end_time'].utc_iso(),
                    'duration': duration,
                    'distance_at_start': float(dist_start.km),
                    'distance_at_end': float(dist_end.km),
                    'distance_at_peak': float(dist_peak_value),
                    'peak_altitude': float(alt_peak_value),
                    'start_azimuth': start_az_value,
                    'end_azimuth': end_az_value,
                    'peak_azimuth': float(az_peak_value),
                    'method': 'find_events',
                    'estimated_end': True
                })

                event_id += 1

        # Deduplicate events using a clustering approach
        events_by_norad = {}
        for event in events:
            norad_id = event['norad_id']
            if norad_id not in events_by_norad:
                events_by_norad[norad_id] = []
            events_by_norad[norad_id].append(event)

        deduplicated_events = []
        for norad_id, satellite_events in events_by_norad.items():
            # Sort events by start time
            satellite_events.sort(key=lambda e: e['event_start'])
            
            # Cluster overlapping events
            clusters = []
            current_cluster = [satellite_events[0]]
            
            for i in range(1, len(satellite_events)):
                current_event = satellite_events[i]
                last_event = current_cluster[-1]
                
                # Check if current event overlaps with the last event in current cluster
                if (current_event['event_start'] < last_event['event_end'] and 
                        current_event['event_end'] > last_event['event_start']):
                    # Add to current cluster
                    current_cluster.append(current_event)
                else:
                    # Start a new cluster
                    clusters.append(current_cluster)
                    current_cluster = [current_event]
            
            # Add the last cluster
            if current_cluster:
                clusters.append(current_cluster)
            
            # Select the best event from each cluster
            for cluster in clusters:
                find_events_candidates = [e for e in cluster if e.get('method') == 'find_events']
                if find_events_candidates:
                    best = max(find_events_candidates, key=lambda e: e['peak_altitude'])
                else:
                    best = max(cluster, key=lambda e: e['peak_altitude'])
            
                deduplicated_events.append(best)

        # Apply final sorting and ID renumbering
        deduplicated_events.sort(key=lambda e: e['event_start'])

        # Apply final sorting and ID renumbering
        # deduplicated_events.sort(key=lambda e: e['event_start'])
        for i, event in enumerate(deduplicated_events, 1):
            event['id'] = i

            # Remove the method field as it's just for internal use
            if 'method' in event:
                del event['method']

        events = deduplicated_events

        # Convert to JSON
        events = json.loads(json.dumps(events, cls=ModelEncoder))
        
        
        
        reply['data'] = events
        reply['parameters'] = {
            'tle_count': len(tle_groups),
            'hours': hours,
            'above_el': above_el,
            'step_minutes': step_minutes
        }
        reply['success'] = True

    except Exception as e:
        logger.error(f"Failed to calculate satellite events, error: {e}")
        logger.exception(e)
        reply['success'] = False
        reply['error'] = str(e)

    return reply


def analyze_satellite_orbit(satellite):
    """
    Analyze a satellite's orbit to determine if it's geosynchronous or geostationary.

    :param satellite: A Skyfield EarthSatellite object
    :return: Dictionary with orbit analysis results
    """
    try:
        # In Skyfield, the orbital elements are accessed differently
        # Semi-major axis is in earth radii, convert to km
        semi_major_axis = satellite.model.a * 6378.137  # Earth radius in km
        eccentricity = satellite.model.ecco
        inclination = np.degrees(satellite.model.inclo)  # Convert radians to degrees

        # Calculate orbital period (in minutes)
        # Using Kepler's Third Law: T² ∝ a³
        period_minutes = 2 * np.pi * np.sqrt(semi_major_axis**3 / 398600.4418) / 60

        # Check if period matches sidereal day (~23h 56m or 1436 minutes)
        # Use 30 minutes tolerance to account for orbital variations
        period_ok = abs(period_minutes - 1436) < 30

        # Determine orbit type
        is_geosynchronous = period_ok
        is_geostationary = is_geosynchronous and (abs(inclination) < 5) and (eccentricity < 0.1)

        return {
            "is_geosynchronous": is_geosynchronous,
            "is_geostationary": is_geostationary,
            "orbital_period_minutes": round(period_minutes, 2),
            "inclination": round(inclination, 2),
            "eccentricity": round(eccentricity, 4)
        }
    except (AttributeError, ValueError, TypeError) as e:
        logger.warning(f"Error analyzing satellite orbit: {e}")
        return {
            "is_geosynchronous": False,
            "is_geostationary": False,
            "error": str(e)
        }

def calculate_azimuth_path(azimuths):
    """
    Calculate the display parameters for a satellite path on a clockwise-only radar widget.

    This function determines the correct start and end points to draw a clockwise arc
    that accurately represents the satellite's path, regardless of the actual direction
    of movement.

    Args:
        azimuths: List of azimuth values in degrees representing a satellite pass

    Returns:
        Tuple of (display_start, display_end, arc_angle)
        - display_start: The starting azimuth for drawing the clockwise arc (0-360)
        - display_end: The ending azimuth for drawing the clockwise arc (0-360)
        - arc_angle: The angle to draw in clockwise direction (0-360)
    """
    if not azimuths or len(azimuths) < 2:
        return 0, 0, 0

    # Normalize all azimuths to 0-360 range
    normalized = [az % 360 for az in azimuths]

    # Get the actual start and end azimuths
    actual_start = normalized[0]
    actual_end = normalized[-1]

    # Determine if the satellite is actually moving clockwise or counterclockwise
    is_clockwise = False
    total_movement = 0

    for i in range(len(normalized) - 1):
        current = normalized[i]
        next_az = normalized[i+1]

        # Calculate difference, handling north crossing
        diff = next_az - current

        # Adjust for crossing north
        if diff > 180:
            diff -= 360
        elif diff < -180:
            diff += 360

        total_movement += diff

    # If total movement is negative, the satellite is moving clockwise
    is_clockwise = total_movement < 0

    # For a clockwise-only display, we need to adjust based on actual movement:
    if is_clockwise:
        # Already clockwise, display as is
        display_start = actual_start
        display_end = actual_end

        # Calculate the clockwise angle
        if display_end > display_start:
            arc_angle = 360 - (display_end - display_start)
        else:
            arc_angle = display_start - display_end
    else:
        # Counterclockwise movement; reverse start and end for clockwise display
        display_start = actual_end
        display_end = actual_start

        # Calculate the clockwise angle
        if display_end > display_start:
            arc_angle = 360 - (display_end - display_start)
        else:
            arc_angle = display_start - display_end

    return display_start, display_end, arc_angle



def backtrack_rise_time(satellite, observer, t0, above_el, backtrack_hours=6.0):
    """
    Work backward in time to find when a satellite actually rose above the horizon
    when it's already visible at start time.
    """
    # Create a timescale that goes backward from t0
    ts = t0.ts
    t_start = t0 - (backtrack_hours / 24.0)

    # Use find_events to find any rise events in the past
    times, events_type = satellite.find_events(
        observer,
        t_start,
        t0,
        altitude_degrees=above_el
    )

    # If we found any rise events, the last one is the start of the current pass
    rise_events = [(time, event_type) for time, event_type in zip(times, events_type) if event_type == 0]
    if rise_events:
        # Return the most recent rise event
        return rise_events[-1][0]

    # If no rise events found, use coarse timestep method to approximate
    difference = satellite - observer
    step_minutes = 5  # Use a coarser timestep for efficiency
    t_points = t_start + (np.arange(0, int(backtrack_hours * 60), step_minutes) / (24.0 * 60.0))

    # Calculate altitudes going backward
    altitudes = []
    for t in t_points:
        topocentric = difference.at(t)
        alt, _, _ = topocentric.altaz()
        altitudes.append(float(alt.degrees))

    # Find transitions from below to above elevation threshold
    above_threshold = np.array(altitudes) > above_el

    # Walk through backward and find first point where satellite is below threshold
    for i in range(len(above_threshold)):
        if not above_threshold[i]:
            # Return the time just after this point (when it first appeared)
            if i < len(t_points) - 1:
                # Interpolate to find a more precise time
                return t_points[i+1]
            break

    # If we get here, we couldn't find a rise time, so return t0
    return t0