# Copyright (c) 2024 Efstratios Goudelis
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# This file contains code partially generated by Claude 3.7 Sonnet.


import json
import logging
import numpy as np
from common import async_timeit
from skyfield.api import Loader, Topos, EarthSatellite
from models import ModelEncoder
from skyfield.api import load, wgs84, EarthSatellite
from typing import List, Dict, Union, Tuple, Optional


logger = logging.getLogger('passes-worker')



def calculate_next_events(tle_groups: list[list[str]], home_location: dict[str, float], hours: float = 6.0,
                          above_el=0, step_minutes=1) -> dict:
    """
    This function calculates upcoming satellite observation events based on TLE lines, observation location,
    duration, elevation threshold, and time step. It combines Skyfield's find_events method with
    a more thorough time-step approach to ensure all passes are detected.

    :param tle_groups: List of lists containing three strings each: [norad_id, TLE line 1, TLE line 2]
    :param home_location: Dictionary containing 'lat' and 'lon' keys with float values for observer location
    :param hours: Observation duration in hours.
    :param above_el: Minimum elevation angle (in degrees) above the horizon for
        an event to be considered. Default is 0.
    :param step_minutes: Time step in minutes for evaluating satellite positions.
        Smaller time steps increase calculation accuracy. Default is 0.5 minutes.
    :return: Dictionary containing the calculated satellite pass events,
        parameters used for computation, and a success flag.
    :rtype: dict
    """

    reply: dict[str, Union[bool, None, list, None, dict, str]] = {'success': None, 'data': None, 'parameters': None, 'error': None}
    events = []

    logger.info(f"Calculating passes for {len(tle_groups)} satellites for the next {hours} hours.")

    try:
        assert isinstance(tle_groups, list), "tle_groups must be a list of lists"
        assert all(len(group) == 3 for group in tle_groups), "Each TLE group must contain norad_id and 2 TLE lines"
        assert isinstance(home_location, dict), "home_location must be a dictionary"
        assert 'lat' in home_location and 'lon' in home_location, "home_location must contain 'lat' and 'lon' keys"

        # set a temporary folder for the skyfield library to do its thing
        skyfieldloader = Loader('/tmp/skyfield-data')  # or any preferred path
        ts = skyfieldloader.timescale()

        homelat = float(home_location['lat'])
        homelon = float(home_location['lon'])

        # Coordinates can be in decimal degrees:
        observer = Topos(latitude_degrees=homelat, longitude_degrees=homelon)

        # Build a time range for pass calculation
        t0 = ts.now()
        t_end = t0 + (hours / 24.0)

        # Step through times using the original step_minutes approach for thoroughness
        # This helps catch passes that might be missed by find_events()
        t_points = t0 + (np.arange(0, int(hours * 60), step_minutes) / (24.0 * 60.0))

        event_id = 1
        for tle_group in tle_groups:
            norad_id, line1, line2 = tle_group

            satellite = EarthSatellite(
                line1,
                line2,
                name=f"satellite_{norad_id}"
            )

            # Check if it is geo stationary
            satellite_orbit_info = analyze_satellite_orbit(satellite)
            is_geostationary = satellite_orbit_info['is_geostationary']
            is_geosynchronous = satellite_orbit_info['is_geosynchronous']

            # APPROACH 1: Use traditional time-step method to ensure we don't miss any passes
            difference = satellite - observer
            altitudes = []
            azimuths = []
            distances = []

            for t in t_points:
                topocentric = difference.at(t)
                alt, az, distance = topocentric.altaz()
                altitudes.append(float(alt.degrees))
                azimuths.append(float(az.degrees))
                distances.append(float(distance.km))

            # Find "passes" by looking for intervals where alt > above_el
            above_threshold = np.array(altitudes) > above_el

            # For a simple pass report, find start/end indices of each pass
            passes = []
            in_pass = False
            pass_start_index = None

            for i in range(len(above_threshold)):
                if above_threshold[i] and not in_pass:
                    # We are just now rising above the threshold
                    in_pass = True
                    pass_start_index = i

                elif not above_threshold[i] and in_pass:
                    # We just fell below the threshold
                    in_pass = False
                    pass_end_index = i - 1  # Last index when above the threshold
                    passes.append((pass_start_index, pass_end_index))

            # If the last pass goes until the end of the array, close it out
            if in_pass:
                passes.append((pass_start_index, len(above_threshold) - 1))

            # Process the passes found by the time-step method
            for start_i, end_i in passes:
                start_time = t_points[start_i]
                end_time = t_points[end_i]

                # Extract the slice of data for this pass
                pass_altitudes = altitudes[start_i:end_i + 1]
                pass_azimuths = azimuths[start_i:end_i + 1]
                pass_distances = distances[start_i:end_i + 1]

                # Find the index of maximum elevation within this pass
                peak_i = np.argmax(pass_altitudes)
                peak_time = t_points[start_i + peak_i]

                duration = end_time.utc_datetime() - start_time.utc_datetime()

                events.append({
                    'id': event_id,
                    'norad_id': norad_id,
                    'is_geostationary': is_geostationary,
                    'is_geosynchronous': is_geosynchronous,
                    'event_start': start_time.utc_iso(),
                    'event_end': end_time.utc_iso(),
                    'duration': duration,
                    'distance_at_start': float(distances[start_i]),
                    'distance_at_end': float(distances[end_i]),
                    'distance_at_peak': float(pass_distances[peak_i]),
                    'peak_altitude': float(pass_altitudes[peak_i]),
                    'max_azimuth': float(max(pass_azimuths)),
                    'min_azimuth': float(min(pass_azimuths)),
                    'method': 'time-step'  # Mark the method used to find this pass
                })
                event_id += 1

            # APPROACH 2: Also use find_events method for more precise timing
            # Find all rise/culminate/set events in the time window
            times, events_type = satellite.find_events(
                observer,
                t0,
                t_end,
                altitude_degrees=above_el
            )

            # First, check if the satellite is already visible at the start time
            topocentric = difference.at(t0)
            alt, az, distance = topocentric.altaz()
            already_visible = alt.degrees > above_el

            # Process the events into passes
            current_pass = {}

            # If already visible at start time and first event is not a rise event
            if already_visible and (len(times) == 0 or events_type[0] != 0):
                current_pass = {
                    'start_time': t0,
                    'norad_id': norad_id
                }

            # Process all the find_events results
            for i, (time, event_type) in enumerate(zip(times, events_type)):
                if event_type == 0:  # Rise event
                    # Start a new pass
                    current_pass = {
                        'start_time': time,
                        'norad_id': norad_id
                    }
                elif event_type == 1 and 'start_time' in current_pass:  # Culmination event
                    # This is the peak of the current pass
                    current_pass['peak_time'] = time
                elif event_type == 2 and 'start_time' in current_pass:  # Set event
                    # This completes the current pass
                    current_pass['end_time'] = time

                    # Calculate additional information for this pass
                    topocentric = difference.at(current_pass['start_time'])
                    alt_start, az_start, dist_start = topocentric.altaz()

                    if 'peak_time' in current_pass:
                        topocentric = difference.at(current_pass['peak_time'])
                        alt_peak, az_peak, dist_peak = topocentric.altaz()
                        alt_peak_value = float(alt_peak.degrees)
                        az_peak_value = float(az_peak.degrees)
                        dist_peak_value = float(dist_peak.km)
                    else:
                        # If we don't have a culmination event, find the peak
                        # Check several points between start and end
                        num_checks = 20
                        check_times = current_pass['start_time'] + np.linspace(
                            0,
                            (current_pass['end_time'].tt - current_pass['start_time'].tt),
                            num_checks
                        )

                        max_alt = float(alt_start.degrees)
                        peak_time = current_pass['start_time']
                        peak_az = float(az_start.degrees)
                        peak_dist = float(dist_start.km)

                        for check_time in check_times:
                            topocentric = difference.at(check_time)
                            check_alt, check_az, check_dist = topocentric.altaz()
                            if check_alt.degrees > max_alt:
                                max_alt = float(check_alt.degrees)
                                peak_time = check_time
                                peak_az = float(check_az.degrees)
                                peak_dist = float(check_dist.km)

                        current_pass['peak_time'] = peak_time
                        alt_peak_value = max_alt
                        az_peak_value = peak_az
                        dist_peak_value = peak_dist

                    topocentric = difference.at(current_pass['end_time'])
                    alt_end, az_end, dist_end = topocentric.altaz()

                    duration = current_pass['end_time'].utc_datetime() - current_pass['start_time'].utc_datetime()

                    events.append({
                        'id': event_id,
                        'norad_id': norad_id,
                        'event_start': current_pass['start_time'].utc_iso(),
                        'event_end': current_pass['end_time'].utc_iso(),
                        'duration': duration,
                        'distance_at_start': float(dist_start.km),
                        'distance_at_end': float(dist_end.km),
                        'distance_at_peak': float(dist_peak_value),
                        'peak_altitude': float(alt_peak_value),
                        'max_azimuth': float(max(float(az_start.degrees),
                                                 float(az_peak_value),
                                                 float(az_end.degrees))),
                        'min_azimuth': float(min(float(az_start.degrees),
                                                 float(az_peak_value),
                                                 float(az_end.degrees))),
                        'method': 'find_events'  # Mark the method used to find this pass
                    })

                    event_id += 1
                    current_pass = {}

            # Handle incomplete passes (satellite visible at the end of time window)
            if current_pass and 'start_time' in current_pass:
                # We have a pass that started but didn't finish in our time window

                # Find the culmination point if we don't have one
                if 'peak_time' not in current_pass:
                    # Sample points to find maximum altitude
                    num_checks = 20
                    check_times = current_pass['start_time'] + np.linspace(
                        0,
                        (t_end.tt - current_pass['start_time'].tt),
                        num_checks
                    )

                    topocentric = difference.at(current_pass['start_time'])
                    alt_start, az_start, dist_start = topocentric.altaz()

                    max_alt = float(alt_start.degrees)
                    peak_time = current_pass['start_time']
                    peak_az = float(az_start.degrees)
                    peak_dist = float(dist_start.km)

                    for check_time in check_times:
                        topocentric = difference.at(check_time)
                        check_alt, check_az, check_dist = topocentric.altaz()
                        if check_alt.degrees > max_alt:
                            max_alt = float(check_alt.degrees)
                            peak_time = check_time
                            peak_az = float(check_az.degrees)
                            peak_dist = float(check_dist.km)

                    current_pass['peak_time'] = peak_time
                    alt_peak_value = max_alt
                    az_peak_value = peak_az
                    dist_peak_value = peak_dist
                else:
                    topocentric = difference.at(current_pass['peak_time'])
                    alt_peak, az_peak, dist_peak = topocentric.altaz()
                    alt_peak_value = float(alt_peak.degrees)
                    az_peak_value = float(az_peak.degrees)
                    dist_peak_value = float(dist_peak.km)

                # Use t_end as the end time for now
                current_pass['end_time'] = t_end

                # Calculate metrics
                topocentric = difference.at(current_pass['start_time'])
                alt_start, az_start, dist_start = topocentric.altaz()

                topocentric = difference.at(current_pass['end_time'])
                alt_end, az_end, dist_end = topocentric.altaz()

                duration = current_pass['end_time'].utc_datetime() - current_pass['start_time'].utc_datetime()

                events.append({
                    'id': event_id,
                    'norad_id': norad_id,
                    'is_geostationary': is_geostationary,
                    'is_geosynchronous': is_geosynchronous,
                    'event_start': current_pass['start_time'].utc_iso(),
                    'event_end': current_pass['end_time'].utc_iso(),
                    'duration': duration,
                    'distance_at_start': float(dist_start.km),
                    'distance_at_end': float(dist_end.km),
                    'distance_at_peak': float(dist_peak_value),
                    'peak_altitude': float(alt_peak_value),
                    'max_azimuth': float(max(float(az_start.degrees),
                                             float(az_peak_value),
                                             float(az_end.degrees))),
                    'min_azimuth': float(min(float(az_start.degrees),
                                             float(az_peak_value),
                                             float(az_end.degrees))),
                    'method': 'find_events',
                    'estimated_end': True
                })

                event_id += 1

        # Deduplicate events by looking for overlapping passes for the same satellite
        # Sort events by start time
        events.sort(key=lambda e: e['event_start'])

        # Find overlapping passes for the same satellite and keep the better one
        # (usually the one found by find_events, which has more precise timing)
        deduplicated_events = []
        i = 0
        while i < len(events):
            current = events[i]

            # Look ahead for overlapping passes of the same satellite
            overlaps = []
            j = i + 1
            while j < len(events):
                if events[j]['norad_id'] != current['norad_id']:
                    j += 1
                    continue

                # Check if start/end times overlap
                if (events[j]['event_start'] < current['event_end'] and
                        events[j]['event_end'] > current['event_start']):
                    overlaps.append(j)

                j += 1

            # If we found overlaps, choose the best event
            if overlaps:
                candidates = [current] + [events[j] for j in overlaps]

                # Prefer the find_events method if available
                find_events_candidates = [e for e in candidates if e.get('method') == 'find_events']
                if find_events_candidates:
                    best = max(find_events_candidates, key=lambda e: e['peak_altitude'])
                else:
                    best = max(candidates, key=lambda e: e['peak_altitude'])

                deduplicated_events.append(best)

                # Skip all the overlapping events
                i = max(overlaps) + 1
            else:
                deduplicated_events.append(current)
                i += 1

        # Apply final sorting and ID renumbering
        deduplicated_events.sort(key=lambda e: e['event_start'])
        for i, event in enumerate(deduplicated_events, 1):
            event['id'] = i

            # Remove the method field as it's just for internal use
            if 'method' in event:
                del event['method']

        events = deduplicated_events

        # Convert to JSON
        events = json.loads(json.dumps(events, cls=ModelEncoder))

        reply['data'] = events
        reply['parameters'] = {'tle_count': len(tle_groups), 'hours': hours, 'above_el': above_el,
                               'step_minutes': step_minutes}
        reply['success'] = True

    except Exception as e:
        logger.error(f"Failed to calculate satellite events, error: {e}")
        logger.exception(e)
        reply['success'] = False
        reply['error'] = str(e)

    return reply


def analyze_satellite_orbit(satellite):
    """
    Analyze a satellite's orbit to determine if it's geosynchronous or geostationary.

    :param satellite: A Skyfield EarthSatellite object
    :return: Dictionary with orbit analysis results
    """
    try:
        # In Skyfield, the orbital elements are accessed differently
        # Semi-major axis is in earth radii, convert to km
        semi_major_axis = satellite.model.a * 6378.137  # Earth radius in km
        eccentricity = satellite.model.ecco
        inclination = np.degrees(satellite.model.inclo)  # Convert radians to degrees

        # Calculate orbital period (in minutes)
        # Using Kepler's Third Law: T² ∝ a³
        period_minutes = 2 * np.pi * np.sqrt(semi_major_axis**3 / 398600.4418) / 60

        # Check if period matches sidereal day (~23h 56m or 1436 minutes)
        # Use 30 minutes tolerance to account for orbital variations
        period_ok = abs(period_minutes - 1436) < 30

        # Determine orbit type
        is_geosynchronous = period_ok
        is_geostationary = is_geosynchronous and (abs(inclination) < 5) and (eccentricity < 0.1)

        return {
            "is_geosynchronous": is_geosynchronous,
            "is_geostationary": is_geostationary,
            "orbital_period_minutes": round(period_minutes, 2),
            "inclination": round(inclination, 2),
            "eccentricity": round(eccentricity, 4)
        }
    except (AttributeError, ValueError, TypeError) as e:
        logger.warning(f"Error analyzing satellite orbit: {e}")
        return {
            "is_geosynchronous": False,
            "is_geostationary": False,
            "error": str(e)
        }
